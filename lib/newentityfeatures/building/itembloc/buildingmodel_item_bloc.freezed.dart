// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'buildingmodel_item_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$BuildingModelItemStateTearOff {
  const _$BuildingModelItemStateTearOff();

// ignore: unused_element
  _Initial initial() {
    return const _Initial();
  }

// ignore: unused_element
  _IsBusy isBusy() {
    return const _IsBusy();
  }

// ignore: unused_element
  _IsSaved isSaved() {
    return const _IsSaved();
  }

// ignore: unused_element
  _HasLogicalFailure hasLogicalFailure(String error) {
    return _HasLogicalFailure(
      error,
    );
  }

// ignore: unused_element
  _HasExceptionFailure hasExceptionFailure(String error) {
    return _HasExceptionFailure(
      error,
    );
  }

// ignore: unused_element
  _IsReadyForDetailsPage isReadyForDetailsPage(
      String detailsType, String entityID, String entityType) {
    return _IsReadyForDetailsPage(
      detailsType,
      entityID,
      entityType,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $BuildingModelItemState = _$BuildingModelItemStateTearOff();

/// @nodoc
mixin _$BuildingModelItemState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult isBusy(),
    @required TResult isSaved(),
    @required TResult hasLogicalFailure(String error),
    @required TResult hasExceptionFailure(String error),
    @required
        TResult isReadyForDetailsPage(
            String detailsType, String entityID, String entityType),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult isBusy(),
    TResult isSaved(),
    TResult hasLogicalFailure(String error),
    TResult hasExceptionFailure(String error),
    TResult isReadyForDetailsPage(
        String detailsType, String entityID, String entityType),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult isBusy(_IsBusy value),
    @required TResult isSaved(_IsSaved value),
    @required TResult hasLogicalFailure(_HasLogicalFailure value),
    @required TResult hasExceptionFailure(_HasExceptionFailure value),
    @required TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult isBusy(_IsBusy value),
    TResult isSaved(_IsSaved value),
    TResult hasLogicalFailure(_HasLogicalFailure value),
    TResult hasExceptionFailure(_HasExceptionFailure value),
    TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $BuildingModelItemStateCopyWith<$Res> {
  factory $BuildingModelItemStateCopyWith(BuildingModelItemState value,
          $Res Function(BuildingModelItemState) then) =
      _$BuildingModelItemStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$BuildingModelItemStateCopyWithImpl<$Res>
    implements $BuildingModelItemStateCopyWith<$Res> {
  _$BuildingModelItemStateCopyWithImpl(this._value, this._then);

  final BuildingModelItemState _value;
  // ignore: unused_field
  final $Res Function(BuildingModelItemState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res>
    extends _$BuildingModelItemStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc
class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'BuildingModelItemState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult isBusy(),
    @required TResult isSaved(),
    @required TResult hasLogicalFailure(String error),
    @required TResult hasExceptionFailure(String error),
    @required
        TResult isReadyForDetailsPage(
            String detailsType, String entityID, String entityType),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult isBusy(),
    TResult isSaved(),
    TResult hasLogicalFailure(String error),
    TResult hasExceptionFailure(String error),
    TResult isReadyForDetailsPage(
        String detailsType, String entityID, String entityType),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult isBusy(_IsBusy value),
    @required TResult isSaved(_IsSaved value),
    @required TResult hasLogicalFailure(_HasLogicalFailure value),
    @required TResult hasExceptionFailure(_HasExceptionFailure value),
    @required TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult isBusy(_IsBusy value),
    TResult isSaved(_IsSaved value),
    TResult hasLogicalFailure(_HasLogicalFailure value),
    TResult hasExceptionFailure(_HasExceptionFailure value),
    TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements BuildingModelItemState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$IsBusyCopyWith<$Res> {
  factory _$IsBusyCopyWith(_IsBusy value, $Res Function(_IsBusy) then) =
      __$IsBusyCopyWithImpl<$Res>;
}

/// @nodoc
class __$IsBusyCopyWithImpl<$Res>
    extends _$BuildingModelItemStateCopyWithImpl<$Res>
    implements _$IsBusyCopyWith<$Res> {
  __$IsBusyCopyWithImpl(_IsBusy _value, $Res Function(_IsBusy) _then)
      : super(_value, (v) => _then(v as _IsBusy));

  @override
  _IsBusy get _value => super._value as _IsBusy;
}

/// @nodoc
class _$_IsBusy implements _IsBusy {
  const _$_IsBusy();

  @override
  String toString() {
    return 'BuildingModelItemState.isBusy()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _IsBusy);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult isBusy(),
    @required TResult isSaved(),
    @required TResult hasLogicalFailure(String error),
    @required TResult hasExceptionFailure(String error),
    @required
        TResult isReadyForDetailsPage(
            String detailsType, String entityID, String entityType),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return isBusy();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult isBusy(),
    TResult isSaved(),
    TResult hasLogicalFailure(String error),
    TResult hasExceptionFailure(String error),
    TResult isReadyForDetailsPage(
        String detailsType, String entityID, String entityType),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (isBusy != null) {
      return isBusy();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult isBusy(_IsBusy value),
    @required TResult isSaved(_IsSaved value),
    @required TResult hasLogicalFailure(_HasLogicalFailure value),
    @required TResult hasExceptionFailure(_HasExceptionFailure value),
    @required TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return isBusy(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult isBusy(_IsBusy value),
    TResult isSaved(_IsSaved value),
    TResult hasLogicalFailure(_HasLogicalFailure value),
    TResult hasExceptionFailure(_HasExceptionFailure value),
    TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (isBusy != null) {
      return isBusy(this);
    }
    return orElse();
  }
}

abstract class _IsBusy implements BuildingModelItemState {
  const factory _IsBusy() = _$_IsBusy;
}

/// @nodoc
abstract class _$IsSavedCopyWith<$Res> {
  factory _$IsSavedCopyWith(_IsSaved value, $Res Function(_IsSaved) then) =
      __$IsSavedCopyWithImpl<$Res>;
}

/// @nodoc
class __$IsSavedCopyWithImpl<$Res>
    extends _$BuildingModelItemStateCopyWithImpl<$Res>
    implements _$IsSavedCopyWith<$Res> {
  __$IsSavedCopyWithImpl(_IsSaved _value, $Res Function(_IsSaved) _then)
      : super(_value, (v) => _then(v as _IsSaved));

  @override
  _IsSaved get _value => super._value as _IsSaved;
}

/// @nodoc
class _$_IsSaved implements _IsSaved {
  const _$_IsSaved();

  @override
  String toString() {
    return 'BuildingModelItemState.isSaved()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _IsSaved);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult isBusy(),
    @required TResult isSaved(),
    @required TResult hasLogicalFailure(String error),
    @required TResult hasExceptionFailure(String error),
    @required
        TResult isReadyForDetailsPage(
            String detailsType, String entityID, String entityType),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return isSaved();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult isBusy(),
    TResult isSaved(),
    TResult hasLogicalFailure(String error),
    TResult hasExceptionFailure(String error),
    TResult isReadyForDetailsPage(
        String detailsType, String entityID, String entityType),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (isSaved != null) {
      return isSaved();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult isBusy(_IsBusy value),
    @required TResult isSaved(_IsSaved value),
    @required TResult hasLogicalFailure(_HasLogicalFailure value),
    @required TResult hasExceptionFailure(_HasExceptionFailure value),
    @required TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return isSaved(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult isBusy(_IsBusy value),
    TResult isSaved(_IsSaved value),
    TResult hasLogicalFailure(_HasLogicalFailure value),
    TResult hasExceptionFailure(_HasExceptionFailure value),
    TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (isSaved != null) {
      return isSaved(this);
    }
    return orElse();
  }
}

abstract class _IsSaved implements BuildingModelItemState {
  const factory _IsSaved() = _$_IsSaved;
}

/// @nodoc
abstract class _$HasLogicalFailureCopyWith<$Res> {
  factory _$HasLogicalFailureCopyWith(
          _HasLogicalFailure value, $Res Function(_HasLogicalFailure) then) =
      __$HasLogicalFailureCopyWithImpl<$Res>;
  $Res call({String error});
}

/// @nodoc
class __$HasLogicalFailureCopyWithImpl<$Res>
    extends _$BuildingModelItemStateCopyWithImpl<$Res>
    implements _$HasLogicalFailureCopyWith<$Res> {
  __$HasLogicalFailureCopyWithImpl(
      _HasLogicalFailure _value, $Res Function(_HasLogicalFailure) _then)
      : super(_value, (v) => _then(v as _HasLogicalFailure));

  @override
  _HasLogicalFailure get _value => super._value as _HasLogicalFailure;

  @override
  $Res call({
    Object error = freezed,
  }) {
    return _then(_HasLogicalFailure(
      error == freezed ? _value.error : error as String,
    ));
  }
}

/// @nodoc
class _$_HasLogicalFailure implements _HasLogicalFailure {
  const _$_HasLogicalFailure(this.error) : assert(error != null);

  @override
  final String error;

  @override
  String toString() {
    return 'BuildingModelItemState.hasLogicalFailure(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _HasLogicalFailure &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(error);

  @JsonKey(ignore: true)
  @override
  _$HasLogicalFailureCopyWith<_HasLogicalFailure> get copyWith =>
      __$HasLogicalFailureCopyWithImpl<_HasLogicalFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult isBusy(),
    @required TResult isSaved(),
    @required TResult hasLogicalFailure(String error),
    @required TResult hasExceptionFailure(String error),
    @required
        TResult isReadyForDetailsPage(
            String detailsType, String entityID, String entityType),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return hasLogicalFailure(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult isBusy(),
    TResult isSaved(),
    TResult hasLogicalFailure(String error),
    TResult hasExceptionFailure(String error),
    TResult isReadyForDetailsPage(
        String detailsType, String entityID, String entityType),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (hasLogicalFailure != null) {
      return hasLogicalFailure(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult isBusy(_IsBusy value),
    @required TResult isSaved(_IsSaved value),
    @required TResult hasLogicalFailure(_HasLogicalFailure value),
    @required TResult hasExceptionFailure(_HasExceptionFailure value),
    @required TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return hasLogicalFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult isBusy(_IsBusy value),
    TResult isSaved(_IsSaved value),
    TResult hasLogicalFailure(_HasLogicalFailure value),
    TResult hasExceptionFailure(_HasExceptionFailure value),
    TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (hasLogicalFailure != null) {
      return hasLogicalFailure(this);
    }
    return orElse();
  }
}

abstract class _HasLogicalFailure implements BuildingModelItemState {
  const factory _HasLogicalFailure(String error) = _$_HasLogicalFailure;

  String get error;
  @JsonKey(ignore: true)
  _$HasLogicalFailureCopyWith<_HasLogicalFailure> get copyWith;
}

/// @nodoc
abstract class _$HasExceptionFailureCopyWith<$Res> {
  factory _$HasExceptionFailureCopyWith(_HasExceptionFailure value,
          $Res Function(_HasExceptionFailure) then) =
      __$HasExceptionFailureCopyWithImpl<$Res>;
  $Res call({String error});
}

/// @nodoc
class __$HasExceptionFailureCopyWithImpl<$Res>
    extends _$BuildingModelItemStateCopyWithImpl<$Res>
    implements _$HasExceptionFailureCopyWith<$Res> {
  __$HasExceptionFailureCopyWithImpl(
      _HasExceptionFailure _value, $Res Function(_HasExceptionFailure) _then)
      : super(_value, (v) => _then(v as _HasExceptionFailure));

  @override
  _HasExceptionFailure get _value => super._value as _HasExceptionFailure;

  @override
  $Res call({
    Object error = freezed,
  }) {
    return _then(_HasExceptionFailure(
      error == freezed ? _value.error : error as String,
    ));
  }
}

/// @nodoc
class _$_HasExceptionFailure implements _HasExceptionFailure {
  const _$_HasExceptionFailure(this.error) : assert(error != null);

  @override
  final String error;

  @override
  String toString() {
    return 'BuildingModelItemState.hasExceptionFailure(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _HasExceptionFailure &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(error);

  @JsonKey(ignore: true)
  @override
  _$HasExceptionFailureCopyWith<_HasExceptionFailure> get copyWith =>
      __$HasExceptionFailureCopyWithImpl<_HasExceptionFailure>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult isBusy(),
    @required TResult isSaved(),
    @required TResult hasLogicalFailure(String error),
    @required TResult hasExceptionFailure(String error),
    @required
        TResult isReadyForDetailsPage(
            String detailsType, String entityID, String entityType),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return hasExceptionFailure(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult isBusy(),
    TResult isSaved(),
    TResult hasLogicalFailure(String error),
    TResult hasExceptionFailure(String error),
    TResult isReadyForDetailsPage(
        String detailsType, String entityID, String entityType),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (hasExceptionFailure != null) {
      return hasExceptionFailure(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult isBusy(_IsBusy value),
    @required TResult isSaved(_IsSaved value),
    @required TResult hasLogicalFailure(_HasLogicalFailure value),
    @required TResult hasExceptionFailure(_HasExceptionFailure value),
    @required TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return hasExceptionFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult isBusy(_IsBusy value),
    TResult isSaved(_IsSaved value),
    TResult hasLogicalFailure(_HasLogicalFailure value),
    TResult hasExceptionFailure(_HasExceptionFailure value),
    TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (hasExceptionFailure != null) {
      return hasExceptionFailure(this);
    }
    return orElse();
  }
}

abstract class _HasExceptionFailure implements BuildingModelItemState {
  const factory _HasExceptionFailure(String error) = _$_HasExceptionFailure;

  String get error;
  @JsonKey(ignore: true)
  _$HasExceptionFailureCopyWith<_HasExceptionFailure> get copyWith;
}

/// @nodoc
abstract class _$IsReadyForDetailsPageCopyWith<$Res> {
  factory _$IsReadyForDetailsPageCopyWith(_IsReadyForDetailsPage value,
          $Res Function(_IsReadyForDetailsPage) then) =
      __$IsReadyForDetailsPageCopyWithImpl<$Res>;
  $Res call({String detailsType, String entityID, String entityType});
}

/// @nodoc
class __$IsReadyForDetailsPageCopyWithImpl<$Res>
    extends _$BuildingModelItemStateCopyWithImpl<$Res>
    implements _$IsReadyForDetailsPageCopyWith<$Res> {
  __$IsReadyForDetailsPageCopyWithImpl(_IsReadyForDetailsPage _value,
      $Res Function(_IsReadyForDetailsPage) _then)
      : super(_value, (v) => _then(v as _IsReadyForDetailsPage));

  @override
  _IsReadyForDetailsPage get _value => super._value as _IsReadyForDetailsPage;

  @override
  $Res call({
    Object detailsType = freezed,
    Object entityID = freezed,
    Object entityType = freezed,
  }) {
    return _then(_IsReadyForDetailsPage(
      detailsType == freezed ? _value.detailsType : detailsType as String,
      entityID == freezed ? _value.entityID : entityID as String,
      entityType == freezed ? _value.entityType : entityType as String,
    ));
  }
}

/// @nodoc
class _$_IsReadyForDetailsPage implements _IsReadyForDetailsPage {
  const _$_IsReadyForDetailsPage(
      this.detailsType, this.entityID, this.entityType)
      : assert(detailsType != null),
        assert(entityID != null),
        assert(entityType != null);

  @override
  final String detailsType;
  @override
  final String entityID;
  @override
  final String entityType;

  @override
  String toString() {
    return 'BuildingModelItemState.isReadyForDetailsPage(detailsType: $detailsType, entityID: $entityID, entityType: $entityType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _IsReadyForDetailsPage &&
            (identical(other.detailsType, detailsType) ||
                const DeepCollectionEquality()
                    .equals(other.detailsType, detailsType)) &&
            (identical(other.entityID, entityID) ||
                const DeepCollectionEquality()
                    .equals(other.entityID, entityID)) &&
            (identical(other.entityType, entityType) ||
                const DeepCollectionEquality()
                    .equals(other.entityType, entityType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(detailsType) ^
      const DeepCollectionEquality().hash(entityID) ^
      const DeepCollectionEquality().hash(entityType);

  @JsonKey(ignore: true)
  @override
  _$IsReadyForDetailsPageCopyWith<_IsReadyForDetailsPage> get copyWith =>
      __$IsReadyForDetailsPageCopyWithImpl<_IsReadyForDetailsPage>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult isBusy(),
    @required TResult isSaved(),
    @required TResult hasLogicalFailure(String error),
    @required TResult hasExceptionFailure(String error),
    @required
        TResult isReadyForDetailsPage(
            String detailsType, String entityID, String entityType),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return isReadyForDetailsPage(detailsType, entityID, entityType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult isBusy(),
    TResult isSaved(),
    TResult hasLogicalFailure(String error),
    TResult hasExceptionFailure(String error),
    TResult isReadyForDetailsPage(
        String detailsType, String entityID, String entityType),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (isReadyForDetailsPage != null) {
      return isReadyForDetailsPage(detailsType, entityID, entityType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult isBusy(_IsBusy value),
    @required TResult isSaved(_IsSaved value),
    @required TResult hasLogicalFailure(_HasLogicalFailure value),
    @required TResult hasExceptionFailure(_HasExceptionFailure value),
    @required TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
  }) {
    assert(initial != null);
    assert(isBusy != null);
    assert(isSaved != null);
    assert(hasLogicalFailure != null);
    assert(hasExceptionFailure != null);
    assert(isReadyForDetailsPage != null);
    return isReadyForDetailsPage(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult isBusy(_IsBusy value),
    TResult isSaved(_IsSaved value),
    TResult hasLogicalFailure(_HasLogicalFailure value),
    TResult hasExceptionFailure(_HasExceptionFailure value),
    TResult isReadyForDetailsPage(_IsReadyForDetailsPage value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (isReadyForDetailsPage != null) {
      return isReadyForDetailsPage(this);
    }
    return orElse();
  }
}

abstract class _IsReadyForDetailsPage implements BuildingModelItemState {
  const factory _IsReadyForDetailsPage(
          String detailsType, String entityID, String entityType) =
      _$_IsReadyForDetailsPage;

  String get detailsType;
  String get entityID;
  String get entityType;
  @JsonKey(ignore: true)
  _$IsReadyForDetailsPageCopyWith<_IsReadyForDetailsPage> get copyWith;
}

/// @nodoc
class _$BuildingModelItemEventTearOff {
  const _$BuildingModelItemEventTearOff();

// ignore: unused_element
  _CreateItem createItem(
      BuildingModel item, String entityID, String entityType) {
    return _CreateItem(
      item,
      entityID,
      entityType,
    );
  }

// ignore: unused_element
  _UpdateItem updateItem(
      BuildingModel item, String entityID, String entityType) {
    return _UpdateItem(
      item,
      entityID,
      entityType,
    );
  }

// ignore: unused_element
  _UpdateItemWithDiff updateItemWithDiff(BuildingModel newItem,
      BuildingModel oldItem, String entityID, String entityType) {
    return _UpdateItemWithDiff(
      newItem,
      oldItem,
      entityID,
      entityType,
    );
  }

// ignore: unused_element
  _GetAdditionalDataEntryIDAvailable getAdditionalDataEntryIDAvailable(
      String id, String entityID, String entityType) {
    return _GetAdditionalDataEntryIDAvailable(
      id,
      entityID,
      entityType,
    );
  }

// ignore: unused_element
  _GetForNewEntry getForNewEntry(String entityID, String entityType) {
    return _GetForNewEntry(
      entityID,
      entityType,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $BuildingModelItemEvent = _$BuildingModelItemEventTearOff();

/// @nodoc
mixin _$BuildingModelItemEvent {
  String get entityID;
  String get entityType;

  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required
        TResult createItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
            String entityID, String entityType),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            String id, String entityID, String entityType),
    @required TResult getForNewEntry(String entityID, String entityType),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult createItem(BuildingModel item, String entityID, String entityType),
    TResult updateItem(BuildingModel item, String entityID, String entityType),
    TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
        String entityID, String entityType),
    TResult getAdditionalDataEntryIDAvailable(
        String id, String entityID, String entityType),
    TResult getForNewEntry(String entityID, String entityType),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult createItem(_CreateItem value),
    @required TResult updateItem(_UpdateItem value),
    @required TResult updateItemWithDiff(_UpdateItemWithDiff value),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            _GetAdditionalDataEntryIDAvailable value),
    @required TResult getForNewEntry(_GetForNewEntry value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult createItem(_CreateItem value),
    TResult updateItem(_UpdateItem value),
    TResult updateItemWithDiff(_UpdateItemWithDiff value),
    TResult getAdditionalDataEntryIDAvailable(
        _GetAdditionalDataEntryIDAvailable value),
    TResult getForNewEntry(_GetForNewEntry value),
    @required TResult orElse(),
  });

  @JsonKey(ignore: true)
  $BuildingModelItemEventCopyWith<BuildingModelItemEvent> get copyWith;
}

/// @nodoc
abstract class $BuildingModelItemEventCopyWith<$Res> {
  factory $BuildingModelItemEventCopyWith(BuildingModelItemEvent value,
          $Res Function(BuildingModelItemEvent) then) =
      _$BuildingModelItemEventCopyWithImpl<$Res>;
  $Res call({String entityID, String entityType});
}

/// @nodoc
class _$BuildingModelItemEventCopyWithImpl<$Res>
    implements $BuildingModelItemEventCopyWith<$Res> {
  _$BuildingModelItemEventCopyWithImpl(this._value, this._then);

  final BuildingModelItemEvent _value;
  // ignore: unused_field
  final $Res Function(BuildingModelItemEvent) _then;

  @override
  $Res call({
    Object entityID = freezed,
    Object entityType = freezed,
  }) {
    return _then(_value.copyWith(
      entityID: entityID == freezed ? _value.entityID : entityID as String,
      entityType:
          entityType == freezed ? _value.entityType : entityType as String,
    ));
  }
}

/// @nodoc
abstract class _$CreateItemCopyWith<$Res>
    implements $BuildingModelItemEventCopyWith<$Res> {
  factory _$CreateItemCopyWith(
          _CreateItem value, $Res Function(_CreateItem) then) =
      __$CreateItemCopyWithImpl<$Res>;
  @override
  $Res call({BuildingModel item, String entityID, String entityType});
}

/// @nodoc
class __$CreateItemCopyWithImpl<$Res>
    extends _$BuildingModelItemEventCopyWithImpl<$Res>
    implements _$CreateItemCopyWith<$Res> {
  __$CreateItemCopyWithImpl(
      _CreateItem _value, $Res Function(_CreateItem) _then)
      : super(_value, (v) => _then(v as _CreateItem));

  @override
  _CreateItem get _value => super._value as _CreateItem;

  @override
  $Res call({
    Object item = freezed,
    Object entityID = freezed,
    Object entityType = freezed,
  }) {
    return _then(_CreateItem(
      item == freezed ? _value.item : item as BuildingModel,
      entityID == freezed ? _value.entityID : entityID as String,
      entityType == freezed ? _value.entityType : entityType as String,
    ));
  }
}

/// @nodoc
class _$_CreateItem implements _CreateItem {
  const _$_CreateItem(this.item, this.entityID, this.entityType)
      : assert(item != null),
        assert(entityID != null),
        assert(entityType != null);

  @override
  final BuildingModel item;
  @override
  final String entityID;
  @override
  final String entityType;

  @override
  String toString() {
    return 'BuildingModelItemEvent.createItem(item: $item, entityID: $entityID, entityType: $entityType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _CreateItem &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.entityID, entityID) ||
                const DeepCollectionEquality()
                    .equals(other.entityID, entityID)) &&
            (identical(other.entityType, entityType) ||
                const DeepCollectionEquality()
                    .equals(other.entityType, entityType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(entityID) ^
      const DeepCollectionEquality().hash(entityType);

  @JsonKey(ignore: true)
  @override
  _$CreateItemCopyWith<_CreateItem> get copyWith =>
      __$CreateItemCopyWithImpl<_CreateItem>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required
        TResult createItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
            String entityID, String entityType),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            String id, String entityID, String entityType),
    @required TResult getForNewEntry(String entityID, String entityType),
  }) {
    assert(createItem != null);
    assert(updateItem != null);
    assert(updateItemWithDiff != null);
    assert(getAdditionalDataEntryIDAvailable != null);
    assert(getForNewEntry != null);
    return createItem(item, entityID, entityType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult createItem(BuildingModel item, String entityID, String entityType),
    TResult updateItem(BuildingModel item, String entityID, String entityType),
    TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
        String entityID, String entityType),
    TResult getAdditionalDataEntryIDAvailable(
        String id, String entityID, String entityType),
    TResult getForNewEntry(String entityID, String entityType),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (createItem != null) {
      return createItem(item, entityID, entityType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult createItem(_CreateItem value),
    @required TResult updateItem(_UpdateItem value),
    @required TResult updateItemWithDiff(_UpdateItemWithDiff value),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            _GetAdditionalDataEntryIDAvailable value),
    @required TResult getForNewEntry(_GetForNewEntry value),
  }) {
    assert(createItem != null);
    assert(updateItem != null);
    assert(updateItemWithDiff != null);
    assert(getAdditionalDataEntryIDAvailable != null);
    assert(getForNewEntry != null);
    return createItem(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult createItem(_CreateItem value),
    TResult updateItem(_UpdateItem value),
    TResult updateItemWithDiff(_UpdateItemWithDiff value),
    TResult getAdditionalDataEntryIDAvailable(
        _GetAdditionalDataEntryIDAvailable value),
    TResult getForNewEntry(_GetForNewEntry value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (createItem != null) {
      return createItem(this);
    }
    return orElse();
  }
}

abstract class _CreateItem implements BuildingModelItemEvent {
  const factory _CreateItem(
      BuildingModel item, String entityID, String entityType) = _$_CreateItem;

  BuildingModel get item;
  @override
  String get entityID;
  @override
  String get entityType;
  @override
  @JsonKey(ignore: true)
  _$CreateItemCopyWith<_CreateItem> get copyWith;
}

/// @nodoc
abstract class _$UpdateItemCopyWith<$Res>
    implements $BuildingModelItemEventCopyWith<$Res> {
  factory _$UpdateItemCopyWith(
          _UpdateItem value, $Res Function(_UpdateItem) then) =
      __$UpdateItemCopyWithImpl<$Res>;
  @override
  $Res call({BuildingModel item, String entityID, String entityType});
}

/// @nodoc
class __$UpdateItemCopyWithImpl<$Res>
    extends _$BuildingModelItemEventCopyWithImpl<$Res>
    implements _$UpdateItemCopyWith<$Res> {
  __$UpdateItemCopyWithImpl(
      _UpdateItem _value, $Res Function(_UpdateItem) _then)
      : super(_value, (v) => _then(v as _UpdateItem));

  @override
  _UpdateItem get _value => super._value as _UpdateItem;

  @override
  $Res call({
    Object item = freezed,
    Object entityID = freezed,
    Object entityType = freezed,
  }) {
    return _then(_UpdateItem(
      item == freezed ? _value.item : item as BuildingModel,
      entityID == freezed ? _value.entityID : entityID as String,
      entityType == freezed ? _value.entityType : entityType as String,
    ));
  }
}

/// @nodoc
class _$_UpdateItem implements _UpdateItem {
  const _$_UpdateItem(this.item, this.entityID, this.entityType)
      : assert(item != null),
        assert(entityID != null),
        assert(entityType != null);

  @override
  final BuildingModel item;
  @override
  final String entityID;
  @override
  final String entityType;

  @override
  String toString() {
    return 'BuildingModelItemEvent.updateItem(item: $item, entityID: $entityID, entityType: $entityType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _UpdateItem &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.entityID, entityID) ||
                const DeepCollectionEquality()
                    .equals(other.entityID, entityID)) &&
            (identical(other.entityType, entityType) ||
                const DeepCollectionEquality()
                    .equals(other.entityType, entityType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(entityID) ^
      const DeepCollectionEquality().hash(entityType);

  @JsonKey(ignore: true)
  @override
  _$UpdateItemCopyWith<_UpdateItem> get copyWith =>
      __$UpdateItemCopyWithImpl<_UpdateItem>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required
        TResult createItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
            String entityID, String entityType),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            String id, String entityID, String entityType),
    @required TResult getForNewEntry(String entityID, String entityType),
  }) {
    assert(createItem != null);
    assert(updateItem != null);
    assert(updateItemWithDiff != null);
    assert(getAdditionalDataEntryIDAvailable != null);
    assert(getForNewEntry != null);
    return updateItem(item, entityID, entityType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult createItem(BuildingModel item, String entityID, String entityType),
    TResult updateItem(BuildingModel item, String entityID, String entityType),
    TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
        String entityID, String entityType),
    TResult getAdditionalDataEntryIDAvailable(
        String id, String entityID, String entityType),
    TResult getForNewEntry(String entityID, String entityType),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (updateItem != null) {
      return updateItem(item, entityID, entityType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult createItem(_CreateItem value),
    @required TResult updateItem(_UpdateItem value),
    @required TResult updateItemWithDiff(_UpdateItemWithDiff value),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            _GetAdditionalDataEntryIDAvailable value),
    @required TResult getForNewEntry(_GetForNewEntry value),
  }) {
    assert(createItem != null);
    assert(updateItem != null);
    assert(updateItemWithDiff != null);
    assert(getAdditionalDataEntryIDAvailable != null);
    assert(getForNewEntry != null);
    return updateItem(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult createItem(_CreateItem value),
    TResult updateItem(_UpdateItem value),
    TResult updateItemWithDiff(_UpdateItemWithDiff value),
    TResult getAdditionalDataEntryIDAvailable(
        _GetAdditionalDataEntryIDAvailable value),
    TResult getForNewEntry(_GetForNewEntry value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (updateItem != null) {
      return updateItem(this);
    }
    return orElse();
  }
}

abstract class _UpdateItem implements BuildingModelItemEvent {
  const factory _UpdateItem(
      BuildingModel item, String entityID, String entityType) = _$_UpdateItem;

  BuildingModel get item;
  @override
  String get entityID;
  @override
  String get entityType;
  @override
  @JsonKey(ignore: true)
  _$UpdateItemCopyWith<_UpdateItem> get copyWith;
}

/// @nodoc
abstract class _$UpdateItemWithDiffCopyWith<$Res>
    implements $BuildingModelItemEventCopyWith<$Res> {
  factory _$UpdateItemWithDiffCopyWith(
          _UpdateItemWithDiff value, $Res Function(_UpdateItemWithDiff) then) =
      __$UpdateItemWithDiffCopyWithImpl<$Res>;
  @override
  $Res call(
      {BuildingModel newItem,
      BuildingModel oldItem,
      String entityID,
      String entityType});
}

/// @nodoc
class __$UpdateItemWithDiffCopyWithImpl<$Res>
    extends _$BuildingModelItemEventCopyWithImpl<$Res>
    implements _$UpdateItemWithDiffCopyWith<$Res> {
  __$UpdateItemWithDiffCopyWithImpl(
      _UpdateItemWithDiff _value, $Res Function(_UpdateItemWithDiff) _then)
      : super(_value, (v) => _then(v as _UpdateItemWithDiff));

  @override
  _UpdateItemWithDiff get _value => super._value as _UpdateItemWithDiff;

  @override
  $Res call({
    Object newItem = freezed,
    Object oldItem = freezed,
    Object entityID = freezed,
    Object entityType = freezed,
  }) {
    return _then(_UpdateItemWithDiff(
      newItem == freezed ? _value.newItem : newItem as BuildingModel,
      oldItem == freezed ? _value.oldItem : oldItem as BuildingModel,
      entityID == freezed ? _value.entityID : entityID as String,
      entityType == freezed ? _value.entityType : entityType as String,
    ));
  }
}

/// @nodoc
class _$_UpdateItemWithDiff implements _UpdateItemWithDiff {
  const _$_UpdateItemWithDiff(
      this.newItem, this.oldItem, this.entityID, this.entityType)
      : assert(newItem != null),
        assert(oldItem != null),
        assert(entityID != null),
        assert(entityType != null);

  @override
  final BuildingModel newItem;
  @override
  final BuildingModel oldItem;
  @override
  final String entityID;
  @override
  final String entityType;

  @override
  String toString() {
    return 'BuildingModelItemEvent.updateItemWithDiff(newItem: $newItem, oldItem: $oldItem, entityID: $entityID, entityType: $entityType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _UpdateItemWithDiff &&
            (identical(other.newItem, newItem) ||
                const DeepCollectionEquality()
                    .equals(other.newItem, newItem)) &&
            (identical(other.oldItem, oldItem) ||
                const DeepCollectionEquality()
                    .equals(other.oldItem, oldItem)) &&
            (identical(other.entityID, entityID) ||
                const DeepCollectionEquality()
                    .equals(other.entityID, entityID)) &&
            (identical(other.entityType, entityType) ||
                const DeepCollectionEquality()
                    .equals(other.entityType, entityType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(newItem) ^
      const DeepCollectionEquality().hash(oldItem) ^
      const DeepCollectionEquality().hash(entityID) ^
      const DeepCollectionEquality().hash(entityType);

  @JsonKey(ignore: true)
  @override
  _$UpdateItemWithDiffCopyWith<_UpdateItemWithDiff> get copyWith =>
      __$UpdateItemWithDiffCopyWithImpl<_UpdateItemWithDiff>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required
        TResult createItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
            String entityID, String entityType),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            String id, String entityID, String entityType),
    @required TResult getForNewEntry(String entityID, String entityType),
  }) {
    assert(createItem != null);
    assert(updateItem != null);
    assert(updateItemWithDiff != null);
    assert(getAdditionalDataEntryIDAvailable != null);
    assert(getForNewEntry != null);
    return updateItemWithDiff(newItem, oldItem, entityID, entityType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult createItem(BuildingModel item, String entityID, String entityType),
    TResult updateItem(BuildingModel item, String entityID, String entityType),
    TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
        String entityID, String entityType),
    TResult getAdditionalDataEntryIDAvailable(
        String id, String entityID, String entityType),
    TResult getForNewEntry(String entityID, String entityType),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (updateItemWithDiff != null) {
      return updateItemWithDiff(newItem, oldItem, entityID, entityType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult createItem(_CreateItem value),
    @required TResult updateItem(_UpdateItem value),
    @required TResult updateItemWithDiff(_UpdateItemWithDiff value),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            _GetAdditionalDataEntryIDAvailable value),
    @required TResult getForNewEntry(_GetForNewEntry value),
  }) {
    assert(createItem != null);
    assert(updateItem != null);
    assert(updateItemWithDiff != null);
    assert(getAdditionalDataEntryIDAvailable != null);
    assert(getForNewEntry != null);
    return updateItemWithDiff(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult createItem(_CreateItem value),
    TResult updateItem(_UpdateItem value),
    TResult updateItemWithDiff(_UpdateItemWithDiff value),
    TResult getAdditionalDataEntryIDAvailable(
        _GetAdditionalDataEntryIDAvailable value),
    TResult getForNewEntry(_GetForNewEntry value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (updateItemWithDiff != null) {
      return updateItemWithDiff(this);
    }
    return orElse();
  }
}

abstract class _UpdateItemWithDiff implements BuildingModelItemEvent {
  const factory _UpdateItemWithDiff(
      BuildingModel newItem,
      BuildingModel oldItem,
      String entityID,
      String entityType) = _$_UpdateItemWithDiff;

  BuildingModel get newItem;
  BuildingModel get oldItem;
  @override
  String get entityID;
  @override
  String get entityType;
  @override
  @JsonKey(ignore: true)
  _$UpdateItemWithDiffCopyWith<_UpdateItemWithDiff> get copyWith;
}

/// @nodoc
abstract class _$GetAdditionalDataEntryIDAvailableCopyWith<$Res>
    implements $BuildingModelItemEventCopyWith<$Res> {
  factory _$GetAdditionalDataEntryIDAvailableCopyWith(
          _GetAdditionalDataEntryIDAvailable value,
          $Res Function(_GetAdditionalDataEntryIDAvailable) then) =
      __$GetAdditionalDataEntryIDAvailableCopyWithImpl<$Res>;
  @override
  $Res call({String id, String entityID, String entityType});
}

/// @nodoc
class __$GetAdditionalDataEntryIDAvailableCopyWithImpl<$Res>
    extends _$BuildingModelItemEventCopyWithImpl<$Res>
    implements _$GetAdditionalDataEntryIDAvailableCopyWith<$Res> {
  __$GetAdditionalDataEntryIDAvailableCopyWithImpl(
      _GetAdditionalDataEntryIDAvailable _value,
      $Res Function(_GetAdditionalDataEntryIDAvailable) _then)
      : super(_value, (v) => _then(v as _GetAdditionalDataEntryIDAvailable));

  @override
  _GetAdditionalDataEntryIDAvailable get _value =>
      super._value as _GetAdditionalDataEntryIDAvailable;

  @override
  $Res call({
    Object id = freezed,
    Object entityID = freezed,
    Object entityType = freezed,
  }) {
    return _then(_GetAdditionalDataEntryIDAvailable(
      id == freezed ? _value.id : id as String,
      entityID == freezed ? _value.entityID : entityID as String,
      entityType == freezed ? _value.entityType : entityType as String,
    ));
  }
}

/// @nodoc
class _$_GetAdditionalDataEntryIDAvailable
    implements _GetAdditionalDataEntryIDAvailable {
  const _$_GetAdditionalDataEntryIDAvailable(
      this.id, this.entityID, this.entityType)
      : assert(id != null),
        assert(entityID != null),
        assert(entityType != null);

  @override
  final String id;
  @override
  final String entityID;
  @override
  final String entityType;

  @override
  String toString() {
    return 'BuildingModelItemEvent.getAdditionalDataEntryIDAvailable(id: $id, entityID: $entityID, entityType: $entityType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _GetAdditionalDataEntryIDAvailable &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.entityID, entityID) ||
                const DeepCollectionEquality()
                    .equals(other.entityID, entityID)) &&
            (identical(other.entityType, entityType) ||
                const DeepCollectionEquality()
                    .equals(other.entityType, entityType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(entityID) ^
      const DeepCollectionEquality().hash(entityType);

  @JsonKey(ignore: true)
  @override
  _$GetAdditionalDataEntryIDAvailableCopyWith<
          _GetAdditionalDataEntryIDAvailable>
      get copyWith => __$GetAdditionalDataEntryIDAvailableCopyWithImpl<
          _GetAdditionalDataEntryIDAvailable>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required
        TResult createItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
            String entityID, String entityType),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            String id, String entityID, String entityType),
    @required TResult getForNewEntry(String entityID, String entityType),
  }) {
    assert(createItem != null);
    assert(updateItem != null);
    assert(updateItemWithDiff != null);
    assert(getAdditionalDataEntryIDAvailable != null);
    assert(getForNewEntry != null);
    return getAdditionalDataEntryIDAvailable(id, entityID, entityType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult createItem(BuildingModel item, String entityID, String entityType),
    TResult updateItem(BuildingModel item, String entityID, String entityType),
    TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
        String entityID, String entityType),
    TResult getAdditionalDataEntryIDAvailable(
        String id, String entityID, String entityType),
    TResult getForNewEntry(String entityID, String entityType),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (getAdditionalDataEntryIDAvailable != null) {
      return getAdditionalDataEntryIDAvailable(id, entityID, entityType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult createItem(_CreateItem value),
    @required TResult updateItem(_UpdateItem value),
    @required TResult updateItemWithDiff(_UpdateItemWithDiff value),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            _GetAdditionalDataEntryIDAvailable value),
    @required TResult getForNewEntry(_GetForNewEntry value),
  }) {
    assert(createItem != null);
    assert(updateItem != null);
    assert(updateItemWithDiff != null);
    assert(getAdditionalDataEntryIDAvailable != null);
    assert(getForNewEntry != null);
    return getAdditionalDataEntryIDAvailable(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult createItem(_CreateItem value),
    TResult updateItem(_UpdateItem value),
    TResult updateItemWithDiff(_UpdateItemWithDiff value),
    TResult getAdditionalDataEntryIDAvailable(
        _GetAdditionalDataEntryIDAvailable value),
    TResult getForNewEntry(_GetForNewEntry value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (getAdditionalDataEntryIDAvailable != null) {
      return getAdditionalDataEntryIDAvailable(this);
    }
    return orElse();
  }
}

abstract class _GetAdditionalDataEntryIDAvailable
    implements BuildingModelItemEvent {
  const factory _GetAdditionalDataEntryIDAvailable(
          String id, String entityID, String entityType) =
      _$_GetAdditionalDataEntryIDAvailable;

  String get id;
  @override
  String get entityID;
  @override
  String get entityType;
  @override
  @JsonKey(ignore: true)
  _$GetAdditionalDataEntryIDAvailableCopyWith<
      _GetAdditionalDataEntryIDAvailable> get copyWith;
}

/// @nodoc
abstract class _$GetForNewEntryCopyWith<$Res>
    implements $BuildingModelItemEventCopyWith<$Res> {
  factory _$GetForNewEntryCopyWith(
          _GetForNewEntry value, $Res Function(_GetForNewEntry) then) =
      __$GetForNewEntryCopyWithImpl<$Res>;
  @override
  $Res call({String entityID, String entityType});
}

/// @nodoc
class __$GetForNewEntryCopyWithImpl<$Res>
    extends _$BuildingModelItemEventCopyWithImpl<$Res>
    implements _$GetForNewEntryCopyWith<$Res> {
  __$GetForNewEntryCopyWithImpl(
      _GetForNewEntry _value, $Res Function(_GetForNewEntry) _then)
      : super(_value, (v) => _then(v as _GetForNewEntry));

  @override
  _GetForNewEntry get _value => super._value as _GetForNewEntry;

  @override
  $Res call({
    Object entityID = freezed,
    Object entityType = freezed,
  }) {
    return _then(_GetForNewEntry(
      entityID == freezed ? _value.entityID : entityID as String,
      entityType == freezed ? _value.entityType : entityType as String,
    ));
  }
}

/// @nodoc
class _$_GetForNewEntry implements _GetForNewEntry {
  const _$_GetForNewEntry(this.entityID, this.entityType)
      : assert(entityID != null),
        assert(entityType != null);

  @override
  final String entityID;
  @override
  final String entityType;

  @override
  String toString() {
    return 'BuildingModelItemEvent.getForNewEntry(entityID: $entityID, entityType: $entityType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _GetForNewEntry &&
            (identical(other.entityID, entityID) ||
                const DeepCollectionEquality()
                    .equals(other.entityID, entityID)) &&
            (identical(other.entityType, entityType) ||
                const DeepCollectionEquality()
                    .equals(other.entityType, entityType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(entityID) ^
      const DeepCollectionEquality().hash(entityType);

  @JsonKey(ignore: true)
  @override
  _$GetForNewEntryCopyWith<_GetForNewEntry> get copyWith =>
      __$GetForNewEntryCopyWithImpl<_GetForNewEntry>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required
        TResult createItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItem(
            BuildingModel item, String entityID, String entityType),
    @required
        TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
            String entityID, String entityType),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            String id, String entityID, String entityType),
    @required TResult getForNewEntry(String entityID, String entityType),
  }) {
    assert(createItem != null);
    assert(updateItem != null);
    assert(updateItemWithDiff != null);
    assert(getAdditionalDataEntryIDAvailable != null);
    assert(getForNewEntry != null);
    return getForNewEntry(entityID, entityType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult createItem(BuildingModel item, String entityID, String entityType),
    TResult updateItem(BuildingModel item, String entityID, String entityType),
    TResult updateItemWithDiff(BuildingModel newItem, BuildingModel oldItem,
        String entityID, String entityType),
    TResult getAdditionalDataEntryIDAvailable(
        String id, String entityID, String entityType),
    TResult getForNewEntry(String entityID, String entityType),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (getForNewEntry != null) {
      return getForNewEntry(entityID, entityType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult createItem(_CreateItem value),
    @required TResult updateItem(_UpdateItem value),
    @required TResult updateItemWithDiff(_UpdateItemWithDiff value),
    @required
        TResult getAdditionalDataEntryIDAvailable(
            _GetAdditionalDataEntryIDAvailable value),
    @required TResult getForNewEntry(_GetForNewEntry value),
  }) {
    assert(createItem != null);
    assert(updateItem != null);
    assert(updateItemWithDiff != null);
    assert(getAdditionalDataEntryIDAvailable != null);
    assert(getForNewEntry != null);
    return getForNewEntry(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult createItem(_CreateItem value),
    TResult updateItem(_UpdateItem value),
    TResult updateItemWithDiff(_UpdateItemWithDiff value),
    TResult getAdditionalDataEntryIDAvailable(
        _GetAdditionalDataEntryIDAvailable value),
    TResult getForNewEntry(_GetForNewEntry value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (getForNewEntry != null) {
      return getForNewEntry(this);
    }
    return orElse();
  }
}

abstract class _GetForNewEntry implements BuildingModelItemEvent {
  const factory _GetForNewEntry(String entityID, String entityType) =
      _$_GetForNewEntry;

  @override
  String get entityID;
  @override
  String get entityType;
  @override
  @JsonKey(ignore: true)
  _$GetForNewEntryCopyWith<_GetForNewEntry> get copyWith;
}
